'''
正则表达式 Regular Expression: 
 在 Python 中, 想要使用正则表达式, 需要用到 re 模块!

re 模块中的方法: 
 - re.match()
 - re.search()
 - re.findall()
 - re.sub()
 - re.split()

正则的符号: 
 - 定义正则验证符号: 
    []      表示匹配一组字符, 如 [0-9] 只要是 0~9 的数字都可以匹配, [a-z] 表示 a 到 z 范围内的字母都可匹配.
    \d      匹配任意数字, 相当于 [0-9]
    \D      匹配任意非数字字符, 相当于 [^\d]
        - 注意: ^ 放在方括号外面, 相当于"以...开头", 放在方括号里面, 相当于"非..."
    \s      匹配任意空白字符, 相当于 [\t\n\r\f]
    \S      匹配任意非空白字符, 相当于 [^\s]
    \w      匹配任意数字/字母/下划线, 相当于 [a-zA-Z0-9_]
    \W      匹配任意非数字字母下划线, 相当于 [^\w]
    \\b     匹配一个单词边界, 也就是单词和空格间的位置.
        - 例如, 'py\\b' 可以匹配 'xxx.py xx.txt' 中的 'py', 但无法匹配 'python' 中的 'py'.
        - 注意: '\b' 本身在字符串中表示退格符, 不是正则表达式想要表达的意思, 所以要多加个斜杠, 即 '\\b'
        - 更简单的办法是在正则表达式字符串前面统一加 r, 这样就不会发生转义了, 比如: r'py\b'
    \B      匹配非单词边界, 即 [^\\b]
    \\      匹配反斜杠
    .       表示匹配除换行符(\n)之外的所有字符
 - 定义正则验证次数: 
    *       表示将前面的模式匹配0次或多次(贪婪模式, 即尽可能多的匹配)    >= 0 
    +       表示将前面的模式匹配1次或多次(贪婪模式, 即尽可能多的匹配)    >= 1 
    ?       表示将前面的模式匹配0次或1次(贪婪模式, 即尽可能多的匹配)     0, 1  
    {m}     表示将前面的模式匹配 m 次, 如 [0-9]{4} 就是匹配一个4位的 0~9 的数字字符串
    {m,}    表示将前面的模式匹配 m 次或多次                          >= m
    {m,n}   表示将前面的模式匹配 m 次到 n 次的之间                    n >= x >= m
        - 注意: {m,n} 的 n 和逗号之间不能有空格, 否则无法匹配成功.
 - 分组与其他约束: 
    ^       表示匹配字符串的开始, 即行首
    $       表示匹配字符串的末尾(末尾如果有换行符, 就匹配换行符前面的那个字符), 即行尾
    |       表示或者.
    ()      常常和 '|' 结合起来使用, 用于分组, 比如: 
             - (163|qq) 表示要么匹配 '163', 要么匹配 'qq'. 
'''
import re

print('1. regex 基础'.center(50, '*'))
# 1. re 模块
# 01 re.match('正则表达式', '字符串')
s = '佟丽娅迪丽热巴古力娜扎'
result = re.match('佟丽', s)
print(result) # <re.Match object; span=(0, 2), match='佟丽'>
# 匹配成功, 返回一个 match 对象; 匹配失败, 则返回 None.
result = re.match('迪丽', s)
print(result) # None

# 02 re.search(regex, s)
result = re.search('迪丽', s)
print(result) # <re.Match object; span=(3, 5), match='迪丽'>
# 不难看出, span=(3, 5) 的意思是: 查询结果在字符串的 [3, 5) 处, 同样是含头不含尾.
print(result.span()) # (3, 5), 返回找到的坐标.
print(result.group()) # 迪丽, 返回匹配到的数据.

# 练习: 提取符合规则的字符串 -> 第一个是字母, 第二个是数字, 第三个也是字母
l = 'ab11a1a2cd4gdef123f2b'
# 这里想要匹配的是由三个字符组成的序列: 第一个字母, 第二个数字, 第三个字母.
result = re.search('[a-z][0-9][a-z]', l) 
print(result) # <re.Match object; span=(4, 7), match='a1a'>
'''
总结: 
 - match(): 从开头查找, 找不到就返回 None.
 - search(): 匹配整个字符串, 开头如果没有匹配, 会查询整个字符串.
二者都只返回匹配到的第一个结果.
'''

# 03 re.findall(regex, s): 以列表的形式返回所有符合条件的字符串!
# 练习: 提取符合规则的字符串 -> 第一个是字母, 第二个是数字, 第三个也是字母
l = 'ab11a1a2cd4gdef123f2b'
result = re.findall('[a-z][0-9][a-z]', l)
print(result) # ['a1a', 'd4g', 'f2b']
# findall() 的返回结果是所有符合条件的元素组成的列表!

# 练习: 提取符合规则的字符串 -> 首尾均为字母即可, 如 a1a, a223b, a22334c...
l = 'ab11a1a2cd4gdef123f2b'
result = re.findall('[a-z][0-9]+[a-z]', l)
# 分析: [a-z]表示匹配小写字母, [0-9]+表示匹配数字(至少出现1次, 可以多次出现), [a-z]表示匹配一个小写字母.
print(result) # ['b11a', 'a2c', 'd4g', 'f123f']

# 练习: QQ号码验证 -> 5到11位的纯数字, 且首字符不可以为0
q1 = '4595838b1'
result = re.match('[1-9][0-9]{4,10}', q1)
print(result) # <re.Match object; span=(0, 7), match='4595838'>
'''代码逻辑分析: 
这里按理说不应该匹配成功的, 为何可以匹配成功呢? 
 - [1-9]的意思是第一个字符是 1~9 范围内的数字;
 - [0-9]{4,10}的意思是匹配一个4位到10位之间的 0~9 范围内的数字;
 - 合起来的意思就是: 只要有个数字字符串, 其第一位不为0, 总长度在5~11位之间即可匹配成功;
 - 而 q1 里包含了 '4595838', 所以可以匹配成功, 但这显然不符合我的需求!
对于这个正则表达式, 只要开头能匹配成功(match的特性), 后面都为字母也能匹配成功.
'''
q2 = '2320955829'
result = re.match('^[1-9][0-9]{4,10}$', q2)
print(result)
'''代码逻辑分析:
这里相对于上面的正则表达式有所升级,
 - ^[1-9] 表示一个 1~9 范围内的字符, 且必须以它为字符串开头.
 - [0-9]{4,10}$ 表示匹配4~10位的0~9的数字字符串, 且要以它为结尾.
在正则表达式的开头加上 ^, 结尾加上 $, 就可以使字符串完全匹配正则表达式!
'''

# 练习: 用户名可以是字母或数字下划线, 但必须以字母开头, 且用户名必须在6位或6位以上.
l = ['1abcdef', 'Abcde', 'aaBBccdd', 'A123456']
for s in l:
    result = re.match('^[a-zA-z]\w{5,}$', s)
    print(result)
'''代码逻辑分析: 
 - ^[a-zA-Z] 表示以字母开头
 - \w 表示匹配任意字母/数字/下划线, \w{5,}$ 表示至少匹配5次, 且以之结尾.
'''

# 练习: 找到下列字符串中的所有 .py 文件
msg = 'aa*py bb.txt cc.py dd.png ee.py'
# 找到所有符合条件的部分自然要用 findall()
result = re.findall(r'\w+\.py\b', msg)
print(result) # ['cc.py', 'ee.py']
'''代码逻辑分析: 
- py\b 表示匹配所有空格前的 'py' 字符串.
- \w+  表示匹配任意字母/数字/下划线(\w), 匹配次数为一次或多次(+).
- \.   表示匹配 '.' 本身, 为什么不能直接用点? 因为 '.' 在正则表达式中表示匹配换行符以外的任意字符, 所以需要加斜杠!
- r    r 后面接字符串, 表示此字符串是 raw 字符串, 里面的所有字符都不会发生转义!
    - 上面的 \w 并不是转义字符, 而是 \w 本身就代表着任意字母/数字/下划线!
    - 上面的 \b 也不是转义字符, 其转义字符的含义是退格符, 而在正则表达式中它就代表单词和空格的边界!
    - 上面的 \. 也并非转义字符, 而是因为 . 在正则表达式中表示除了换行符之外的一切字符, 所以这里用 \. 表达点的原本含义!
        - 即 . + * ? \ 在正则表达式中都有其特殊含义, 
        - 而 \. \+ \* \? \\ 表示的是 . + * ? \ 原本的含义: 点 加 星 问号 反斜杠!
所以, 在正则表达式中, 建议经常使用 raw 字符串, 否则会比较麻烦, 比如下面这个例子: 
'''
result = re.findall('\w+\\.py\\b', msg)
print(result) # ['cc.py', 'ee.py']
# 相对于上面的正则表达式, 变得更难以理解了.

# 练习: 正则匹配手机号 -> 第一位为1, 第二位为 3/5/7/8/9, 共11位
s = '17681189866'
result = re.match('^1[3-9][0-9]{9}$', s)
print(result)

# 04 sub(Regex, 替换字符串, 匹配字符串): 对匹配到的内容进行替换.
# 将所有的文件替换成 py 文件
s = 'abc.txt zzz.txt 123.doc '
result = re.sub(r'\.[a-z]{3}\b', '.py', s)
print(result) # abc.py zzz.py 123.py 
'''代码逻辑分析: 
- sub()方法的作用是将匹配到的字符串进行替换, 所以不需要进行完全匹配.
- 这里我们只需要匹配文件后缀, 所以先分析一下后缀的特点有哪些?
    1. 后缀名都包含一个点, 且后缀名的长度均为3
    2. 后缀名的后面都有一个空格
  综合这两点, 可以得出 Regex: r'\.[a-z]{3}\b'
- 然后将匹配到的字符串替换成 '.py' 即可. 
'''
# sub()方法还可以结合函数来进行替换⭐️
def func(temp):
    if temp is not None:
        num = temp.group()
        num = int(num) + 1
        return str(num)
s = 'Ptyhon: 89, Math: 99, English: 59'
result = re.sub(r'[0-9]+', func, s)
'''               ___1___ __2__ _3_
代码逻辑分析: 
 - sub() 会从 3 处拿到字符串, 使用 1 处的规则进行匹配, 只要成功匹配, 就将匹配到的结果
 - 放到 func(temp) 函数中以 temp 的形式传进行, 然后拿着返回值对原字符串进行替换.
 - 成功替换之后继续往后查找, 替换...
sub() 和 findall() 的共同之处在于, 它们都会都这个字符串查找, 并返回所有符合 Regex 的字符串.
'''
print(result) # Ptyhon: 90, Math: 100, English: 60
# 这个方法我只能说神奇, 确实没看懂 func 的参数是如何传递的...

# 05 split(): 对字符串进行切割
s = 'Ptyhon: 89, Math: 99, English: 59'
result = re.split('[:,]', s)
print(result) # ['Ptyhon', ' 89', ' Math', ' 99', ' English', ' 59']
'''代码逻辑分析:
split() 方法也需要传入两个参数, 第一个参数是正则表达式, 第二个参数是待处理字符串. 
 - 但这里的正则表达式是切割方式的正则表达式, 比如这里 [:,] 表示遇到冒号或逗号就进行切割.
 - 返回值是切割后的列表.
'''


print('2. 分组'.center(50, '*'))
# 2. 分组: (a|b|c)
# 匹配 0-100 的数字, 注: 2位数字不可以是 09, 可以是19, 29...
l = ['0', '1', '08', '18', '100', '105', '']
for s in l:
    result = re.search('^[1-9]?[0-9]{1}$|^100$', s)
    if result is not None:
        print(result.group(), end=' ')
else:
    print()
'''代码逻辑分析: 
- [1-9]?[0-9]{1} 当成一个整体来看: [1-9]可以出现0次或1次, [0-9]必须出现1次, 合起来就是在表示
  匹配1位或2位数字, 且1位的时候需要包含0, 2位的时候第一位不能为0!
- ^[1-9]?[0-9]{1}$ 表示以此开头, 以此结尾, 不加的话, 会从 '026' 中匹配 '26'.
- | 表示分组匹配, 也就是"或"的意思.
- ^100$ 仅匹配 100 本身.
'''
'''
为什么终端里经常会出现百分号? 
 因为最后没有输出换行符, 这是终端在提醒你末尾没有加换行符, 只需在程序末尾加一个 print() 即可解决.
'''
# 练习: 用正则表达式匹配 163/QQ 邮箱
l = ['hu@sina.com', 'hu@163.com', 'hu@163*com', 'hu@qq.com', '@qq.com']
for email in l:
    # result = re.match(r'^\w+@163\.com$|^\w+@qq\.com$', email)
    # 代码优化:
    result = re.match(r'^\w+@(163|qq)\.com$', email)
    if result is not None:
        print(result.group(), end=', ')
else:
    print()
'''代码逻辑分析: 
- r     raw 字符串
- ^$    整体匹配
- \w+   一个或多个字母/数字/下划线
- (163|qq): 分组匹配! 要么匹配 163, 要么匹配 qq
- \.    点本身
'''

# 练习: 匹配不是以4, 7结尾的手机号 -> 第一位为1, 长度为11位.
l = ['17681189866', '13135551077', '1234567890', '13112345644', '1311234564a']
for num in l:
    result = re.match('^1[0-9]{9}[0-35689]$', num)
    if result is not None:
        print(result)
'''代码逻辑分析:
- ^$        整体匹配
- [0-9]{9}  一个9位的数字字符串
- [0-35689] 匹配一个不是4和7的数字     
'''

# 爬虫练习: 将区号和电话号码分别提取, 区号为3位或4位, 电话号码为7位, 如 010-1234567
nums = ['010-1234567', '0554-4971887', '0551-123456', '01-1234567']
for num in nums:
    result = re.match(r'^([0-9]{3,4})-([0-9]{7})$', num)
    if result is not None:
        print(result.group(), end=' -> ')
        # group() 也支持分别提取
        print(result.group(1), end=' ') # group(1) 提取第一组的内容
        print(result.group(2)) # group(2) 提取第二组的内容
        # 所以, group() 需要和分组一起使用, 才能发挥最大的效果!

# 爬虫练习: 从 HTML 标签中提取内容
msg1 = '<h1>今天天气怎么样?</h1>'
result = re.match(r'<\w+>(.+)</\w+>', msg1)
print(result.group(1)) # 今天天气怎么样?
# 这里的匹配是正常的

msg2 = '<html><h1>今天天气怎么样?</h1>'
result = re.match(r'<\w+>(.+)</\w+>', msg2)
print(result.group(1)) # <h1>今天天气怎么样?
# 但这里匹配多了个标签, 这个标签是我们不想要的, 怎么办呢? 分组加数字

# 2.1 分组加数字
msg = '<html><h1>今天天气怎么样?</h1>'
result = re.search(r'<([0-9a-zA-Z]+)>(.+)</\1>', msg)
print(result.group(2)) # 今天天气怎么样?
# 这样就解决了上面的问题!
'''代码逻辑分析: 
- 在 HTML 标签内加一个分组 <([0-9a-zA-Z]+)> 这个就是对标签进行匹配
- (.+) 对标签内的内容进行匹配
- </\1> 这里的 \1 表示这里的内容和第一个分组中匹配到的内容必须一样. 比如: 
    - <h1>...</h1> 可以通过匹配
    - <h1>...</h2> 就无法通过匹配了
    - 如果是按照之前的方式, 这两组标签中的内容都可以通过匹配.
'''

# 2.2 对分组进行起名
'''
起名的方式: (?P<名字>Regex) 
使用名字的方式: (?P=名字)
'''
# 现在要提取 HTML 标签中的内容
msg = '<html><h1>hello world</h1></html>'
result = re.match(r'<(?P<LV1>\w+)><(?P<LV2>\w+)>(.+)</(?P=LV2)></(?P=LV1)>', msg)
print(result.group(3)) # hello world
'''分析代码逻辑: 
这里把 HTML 标签也进行分组了.
- <(?P<LV1>\w+)>    <> 是原来的 HTML 标签符号, (?P<LV1>\w+) 表示对分组进行起名:
    - ()        表示对标签内进行的正则匹配进行分组
    - ?P<组名>   对分组进行命名的方式
    - \w+       分组部分的实际正则表达式
    - 这里, 我将这个分组命名为 LV1
- <(?P<LV2>\w+)>    是同样的道理
- (.+)              对标签之间的内容进行正则匹配
- </(?P=LV2)>       使用分组的命名
    - </>       这是每个结尾标签都具有的内容
    - (?P=LV2)  这是对分组命名的具体使用方法, 表示此处的内容必须和分组命名 (?P<LV2>\w+) 匹配到内容相同.
'''


# 3. 贪婪与非贪婪
# 举例说明:
msg = 'abc123abc'
result = re.match(r'abc(\d+)', msg)
print(result) # <re.Match object; span=(0, 6), match='abc123'>
# 匹配的结果是: abc123, 但实际上这里只需 abc1 就已经符合正则表达式了, 
# 这说明这里的结果很贪婪
# 也就是说, Python 中的正则表达式默认是贪婪的! 
'''
- 贪婪模式: 尽可能匹配更多的字符.
- 非贪婪模式: 尽可能匹配更少的字符.

如何是贪婪模式变成非贪婪? 只需在正则表达式中的量词后面加上问号(?)即可.
 - 正则表达式中的量词: * + ? {m} {m,} {m,n}
'''
msg = 'abc123abc'
result = re.match(r'abc(\d+?)', msg)
print(result) # <re.Match object; span=(0, 4), match='abc1'>
# 可见, 变成非贪婪模式了.

# 练习: 从网络上爬取一张图片
path = '<img class="main_img img-hover" data-imgurl="https://img0.baidu.com/it/u=3398816662,541852629&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1280&amp;h=800" style="width: 246px; height: 160px;" src="https://img0.baidu.com/it/u=3398816662,541852629&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1280&amp;h=800">'
# 通过正则匹配, 找出图片链接(一般在 src 中)
result = re.search('src="(.+)"', path)
# 提取出图片路径
img = result.group(1)

import requests
# 根据地址获取图片信息
response = requests.get(img)
# 将图片信息写入本地磁盘(下载)
with open('/Users/hunan/Desktop/test.jpeg', 'wb') as w:
    w.write(response.content) # 具体怎么使用, 需要查询第三方文档

# 以上代码执行完毕, 会在电脑桌面上下载一个图片!
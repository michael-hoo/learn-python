# Lock 锁: 解决多线程同时修改全局变量导致的数据问题.
'''
多线程和多进程最大的不同之处在于:
 - 在多进程中, 同一个变量, 每个进程都有一份自己的拷贝, 即全局变量是相互独立的;
 - 在多线程中, 同一个进程内的所有线程共享全局变量, 这可能会产生数据安全问题.

这个问题在下面的模拟抢票程序中被暴露出来了: 
 - 在下面这个练习中, 我同时使用三个线程进行抢票, 每抢到一张票, 使剩余票数数量减1.
 - 总共100万张票, 我用三个线程分别抢了30万次, 按理说应该剩余10万张票.
 - 但实际上返回的结果是剩余车票341658张(这时没有加锁), 这是为什么呢? 
    - 这是因为在多线程中, 每个线程进入阻塞状态的时机是不一定的, 虽然抢票代码只是简单的一句:
      tickets -= 1, 但它包含了两个动作: ①数量减一; ②赋值.
    - 可能其中一个进程数量减一后准备赋值时, 进程进入阻塞状态了, 而另外一个进程完成了数量减一
      并赋值, 然后先前那个进程重新赋值. 结果是, 两次减1(实际应该减2), 数值上只减少1.
 - (注: 上面这个问题在 Python3.12 中不存在了, 即不加锁剩余票数也是10万张...)
想要解决这个问题, 需要用到 threading 模块中提供的线程锁 - Lock!

GIL(全局解释器锁)
 - 在非 Python 环境中, 对于单核计算机, 同时只能有一个任务在执行, 对于多核计算机, 是可以同时执行
   多个任务的. 但在 Python 中, 无论有多少核, 同时都只能执行一个线程. 这是因为有 GIL. 

Python 多线程的适用场景:
 - 对于 CPU 密集型程序(各种循环处理, 大量数学计算等等), 由于计算工作太多, ticks 计数很快会达到
   阈值, 然后触发 GIL 的释放与再竞争(多个线程来回切换当然是需要消耗资源的), 所以, Python 下的
   多线程对 CPU 密集型代码并不友好. 
 - 对于 IO 密集型程序(文件处理, 网络爬虫等), 使用多线程能有效提升效率. 因为单线程下有 IO 操作会
   进行 IO 等待, 造成不必要的时间浪费, 而开启多线程时, 在线程一进入等待时会自动切换到线程二, 可以
   不浪费 CPU 的资源, 从而提升程序执行效率. 所以 Python 的多线程对 IO 密集型程序比较友好!
   
使用建议:
 - 想要充分利用多核性能, 就用多进程. 因为每个进程有各自独立的 GIL, 互不干扰. 这样就可以真正意义上
   地并行执行, 在 Python 中, 多进程的执行效率优于多线程. 

无论 GIL 还是 Lock, 它们的弊端都是降低运行效率, 但好处是保证了数据的安全性.
'''
import threading
# 创建全局变量
tickets = 1000000 # 这里共有100万张票
# 创建一个锁对象
lock = threading.Lock()

def buy_ticket():
    global tickets
    for i in range(300000):
        # 使用锁之前, 要先获取锁
        lock.acquire()
        try:
            # 对全局变量进行修改
            tickets -= 1
        finally:
            # 锁用完之后一定要释放, 否则其他线程将会阻塞!
            lock.release()
            '''
            当多个线程同时执行 lock.release() 时, 只有一个线程能成功获取锁, 其他线程继续等待, 
            直到获得锁为止. 所以用完锁之后一定要释放, 否则其他线程会一直等下去, 称为死线程.
            这里, 可以通过 try...finally 语句确保 lock.release() 一定会执行!
            '''
        
t1 = threading.Thread(target=buy_ticket, name='抢票线程1')
t2 = threading.Thread(target=buy_ticket, name='抢票线程2')
t3 = threading.Thread(target=buy_ticket, name='抢票线程3')
t1.start()
t2.start()
t3.start()
t1.join()
t2.join()
t3.join()
print('经过抢票之后, 剩余车票还剩{}张.'.format(tickets))
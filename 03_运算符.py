# 算术运算符
## // - 整除
print('01:', 5 // 2) # 结果为2，5 ÷ 2 = 2···1

## % - 取余
print('02:', 5 % 2) # 结果为1，5 ÷ 2 = 2···1

## ** - 次幂
print('03:', 2 ** 3) # 结果为8，2 ^ 3 = 8

# 位运算符：针对二进制数进行计算的运算符。
## 1. & 与：(和 and 类似)都为1，才得1. 0&0=0，0&1=0，1&1=1.
print('04:', 5 & 9) # output: 1
'''
    计算逻辑： 5 & 9 → 0b0101 & 0b1001
    0101
    1001
    ----
    0001 = 1
'''

## 2. | 或：(和 or 类似)有一个1，即为1. 0|0=0, 0|1=1, 1|1=1.
print('05:', 5 | 9) # output: 13
'''
    计算逻辑：5 | 9 = 0b0101 | 0b1001
    0101
    1001
    ----
    1101 = 13
'''

## 3. ^ 按位异或：相同为0，不同为1. 0^0=0, 0^1=1, 1^1=0.
print('06:', 5 ^ 9) # output: 12
'''
    计算逻辑：5 ^ 9 = 0b0101 ^ 0b1001
    0101
    1001
    ----
    1100 = 12 
'''

## 4. ~ 取反：
'''
    背景知识补充：
    1 byte(字节) = 8 bit(位)
    而通常一个整数是在内存中占4个字节，即32位。也就是说，我们电脑中存一个整数5，实际是这样的：
    00000000 00000000 00000000 00000101 (明白了，这个可能和计算机的32位、64位有关！)
        这里有点困惑，uft-8 编码中，数字和英文字母只占一个字节(汉字3个)，这里为何说是4个字节？
        明白了，uft-8 规定的是 0～9 每个数字占一个字节，而这里说的是最大的整数占4个字节，不是一回事。
    
    原码、反码、补码：
    原码：0101
    反码：1010 (按位取反)
    补码：1011 (反码+1)

    有点理解了：原码取反加一得到补码，补码取反加一得到原码。
    对数字5(二进制表示为0b0101)使用按位取反操作就是如下这样：
    00000000 00000000 00000000 00000101
    -----------------------------------
    11111111 11111111 11111111 11111010 → 结果为-6
    怎么看出是-6的？因为现代计算机都是用补码表示负数，只需看其符号位(左边第一位)便知其是正数还是负数。
    这里左边第一位是1，表示它是负数，而这一串是它的补码，获取其原码的方式同样是“按位取反加一”。
    11111111 11111111 11111111 11111010
    -----------------------------------
    00000000 00000000 00000000 00000101 (按位取反)
    00000000 00000000 00000000 00000110 (加1)，记得在前面加上负号！→ -6
'''
print('07:', ~5) # output: -6
print('07:', ~6) # output: -7
print('07:', ~7) # output: -8
print('07:', ~100) # output: -101
print('07:', ~-100) # output: 99
print('07:', ~0) # output: -1
'''
    所以我们可以得出结论：按位取反就是“加一之后变成相反数”。
    ~5 → 5+1=6 → -6
    ～-100 → -100+1=-99 → 99
    ～0 → 0+1=1 → -1
'''
### 负数的二进制表示：根据上面的知识，可知 ~-9 = 8，那么，我们对8进行按位取反即可得 -9 的二进制表示！
print('08:', bin(~8)) # output: -0b1001
'''
    这里的输出并非 -9 在计算机中的样子！我们对8的二进制表示进行按位取反加一操作：
    00000000 00000000 00000000 00001000
    -----------------------------------
    11111111 11111111 11111111 11110111 (按位取反)
    11111111 11111111 11111111 11111000 (加一) → -9
'''

## 5. << 左移运算符：全部左移x位，高位丢弃，低位补0.
n = 12 # 其对应的二进制数为 0b1100
print('09:', n << 1) # output: 24, 12 * 2^1
print('09:', n << 2) # output: 48, 12 * 2^2
print('09:', n << 3) # output: 96, 12 * 2^3
'''
    总结规律：一个数字 n 左移 x 位，等价于 n * 2^x
    运算逻辑：0b1100 → 00001100
    00001100
    00011000 → 左移1位，24
    00110000 → 左移2位，48
    01100000 → 左移3位，96
'''

## 6. >> 右移运算符：全部右移x位，低位丢弃，高位补0.
print('10:', n >> 1) # output: 6, 12 // 2^1
print('10:', n >> 2) # output: 3, 12 // 2^2
print('10:', n >> 3) # output: 1, 12 // 2^3
'''
    总结规律：一个数字 n 右移 x 位，等价于 n // 2^x
    运算逻辑：0b1100 → 00001100
    00001100
    00000110 → 右移1位，6
    00000011 → 右移2位，3
    00000001 → 右移3位，1
'''
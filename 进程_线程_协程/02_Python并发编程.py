'''
本节主要介绍:
 1. Python实现并发编程的三种方式: 多进程/多线程/多协程
 2. 多进程/多线程/多协程之间的区别
 3. 怎样根据任务的性质选择合适的奇数?
'''

'''
Python实现并发编程, 主要有以下三种方式:
 - 多进程: Process
 - 多线程: Thread
 - 多协程: Coroutine

想要理解这三者的区别, 需要先引入"CPU密集型"计算和"IO密集型"计算这两个概念.
1. 什么是CPU密集型计算? 什么是IO密集型计算?
   CPU密集型计算(CPU-bound):
    - 此类任务的I/O一般在很短时间内就可以完成, 而CPU需要进行长时间的运行和计算.
    - 此类任务的特点是CPU占用率相当高. 
    - 例如: 压缩/解压缩, 加密/解密, 正则表达式搜索...
   I/O密集型计算(I/O-bound):
    - 此类任务运行的一般情况是CPU在等I/O的读写操作.
    - 此类任务的特点是CPU占用率较低.
    - 例如: 文件处理, 网络爬虫, 读写数据库... 
2. 多线程、多进程、多协程的对比
   多进程 
    - 优点: 可以利用多核CPU进行并行计算(这三种技术中, 只有多进程可以利用多核CPU). 
    - 缺点: 进程占用资源最多, 进程可启动数目最少.
    - 适用: CPU密集型计算(↑)
   多线程
    - 优点: 相比进程, 更轻量级, 占用资源少.
    - 缺点: 
         - 相比进程: 多线程只能并发执行, 不能利用多CPU进行计算 (GIL)  
         - 相比协程: 线程的启动数目有限制, 占用内存资源, 线程切换有开销.
    - 适用: I/O密集型计算, 且同时运行的任务量不多.
   多协程
    - 优点: 内存开销最少, 且协程可同时启动的数目超级多!
    - 缺点: 支持的库有限, 代码实现复杂(这不是协程的问题, 这是我的问题).
         - 比如说, 爬虫常用的库 requests 是不支持协程的, 只能用 aiohttp
    - 适用: I/O密集型计算, 且有超多任务需要运行, 以及有现成的协程库支持.
既然已经知道多进程/多线程/多协程之间的差别了, 如何根据任务的类型选择相应的技术也就不难了.
3. 怎样根据任务选择对应技术? 
   通过问自己如下问题来进行选择: 
   ① 该任务是CPU密集型还是IO密集型?
    - CPU密集型 -> 多进程
    - I/O密集型, 继续回答下列三个问题: 
      ② 是否有超多任务需要执行?
      ③ 是否有现成的协程库支持?
      ④ 是否可接受实现的复杂度?
        - 全部回答"是" -> 多协程
        - 有一个为"否" -> 多线程
'''
'''
函数的作用: 封装重复代码, 使代码更简洁!
'''
print('*1-' * 20)
# 1. 函数的定义
import random

# 专门生成验证码的函数
def generate_code():
    s = 'qwertyuiopasdfghjklzxcvbnm1234567890'
    code = ''
    for i in range(4):
        r = random.choice(s) # 从字符串 s 中随机选一位
        code += r
    print(code)

generate_code() # 调用一次函数, 产生一个验证码.

'''
练习: 定义一个 login 函数.
    要求: 
    1. 用户名和密码分别为 admin 和 1234
    2. 输入用户名和密码, 验证是否正确
'''
import time

def login():
    # username, password 的键入最好还是分开, 这里想运用一下 split() 函数.
    username, password = input('请输入您的用户名和密码(用空格隔开):').split()
    if username == 'admin' and password == '1234':
        print('正在登录中...')
        time.sleep(1)
        print('登录成功!')
    else:
        print('用户名或密码错误!')

# login()


# 2. 函数参数: 参数的作用是扩展函数的功能, 使代码更加灵活.
'''
    常见的参数类型:
    1. 位置参数: 最基本的参数, 定义几个就必须往函数中传入几个.
        - 巧记: 位置参数就是"一个萝卜一个坑", 每个参数都有自己的位置.
    2. 默认值参数: 可传可不传, 不传的话就使用默认值. 
        - 想只给位置靠后的某个默认值参数传参, 其他默认值参数使用默认值, 需加上改参数的名字.
        - 默认值参数的好处在于: 可以降低函数的调用难度.
    3. 可变参数
    4. 关键字参数
        - 命名关键字参数
    5. 以上参数的组合
'''
print('*2.1-' * 20)
## 2.1 位置参数
# 定义一个函数计算 x 的平方.
def power(x):
    return x * x

print(power(3)) # 9, 计算3的平方
# 这里的 x 就是位置参数, 调用时必须传入有且一个参数.

# 但如果我们想要计算 x 的三次方, 该怎么办? 可以传入多个参数!
def power(x, n):
    return x ** n

print(power(2, 3)) # 8, 计算2的三次方
# 这样修改后, power 函数可以计算 x 的任意次方. x 和 n 都是位置参数, 所以就算是计算平方, 也要传两个参数.
print(power(3, 2)) # 9, 计算3的平方
# 这样修改之后功能确实强大了, 但计算平方不像之前那样方便了: 只传一个参数就能计算.
# 这时, 我们就需要使用默认值参数.

print('*2.2-' * 20)
## 2.2 默认值参数
def power(x, n=2):
    return x ** n
# 由于经常需要计算平方, 这里把 n 的默认值设为2.
# 这样我们既可以这样很方便地计算 x 的平方.
print(power(3)) # 9
# 也可以计算 x 的任意次方!
print(power(2, 5)) # 32
'''
这里需要注意:
1. 默认值参数需要放在位置参数的后面.
2. 定义默认值参数的时候, 通常把相对更不容易发生改变的值放在靠后的位置.
'''
# 默认值参数的最大好处是可以降低函数的调用难度, 下面举例说明.
# 练习: 我们需要写一个一年级小学生的注册函数, 需要传入姓名和性别.
def enroll(name, gender):
    print('姓名:', name)
    print('性别:', gender)

enroll('胡楠', '男')
# 这里调用函数需要传递不多不少两个参数.
# 但如果我们还要求继续传入年龄和户籍所在地, 怎么办? 用默认值参数!
    # 因为刚入学的一年级新生大部分都是6岁, 且户籍在学校所在城市.
def enroll(name, gender, age=6, city='合肥'):
    print('姓名', name)
    print('性别', gender)
    print('年龄:', age)
    print('城市:', city)

# 这样, 我们在调用函数时, 一般只需要传入2个必须的参数, 
enroll('小明', '男')
# 只有在遇到与默认条件不符的学生信息时, 才传入更多参数.
enroll('胡楠', '男', 31, '淮南')
# 需要注意的是, 调用函数时, 参数默认是按顺序提供的, 如果想不按照顺序为指定默认参数赋值, 可以这样操作:
enroll('小红', '女', city='南京') # 跳过 age 直接给 city 传参, 这样 age 就继续使用默认值.

# 注意: 默认值参数有个大坑! 即默认值参数必须指向不可变对象!
# # 举例说明: 我想实现这样的功能, 传入一个 list, 在 list 的末尾加上 'end' 并返回.
# def add_end(L=[]): # 这里的默认参数为可变对象 list.
#     L.append('end')
#     return L
# l1 = [1, 2, 3]
# l2 = ['a', 'b', 'c']
# print(add_end(l1)) # [1, 2, 3, 'end']
# print(add_end(l2)) # ['a', 'b', 'c', 'end']
# # 这样看功能实现的很好, 但当我多次在空列表上执行此函数时:
# print(add_end([])) # ['end']
# print(add_end([])) # ['end']
# print(add_end([])) # ['end']
# # 没问题啊, 是廖雪峰出错了吗?


print('*2.3-' * 20)
## 2.3 可变参数
# 可变参数, 顾名思义, 就是传入的参数是可变的, 可以是1个, 也可以是2个, 甚至任意多个, 还可以是0个.
# 举例说明: 我们想要实现传入 a,b,c..., 计算 a^2 + b^2 + c^2 + ... 的结果.
# 由于需要计算的数字的数量不确定, 我们首先想到把参数 a,b,c... 以一个 list 或 tuple 的形式传进来.
def calc(numbers):
    sum = 0
    for n in numbers:
        sum += n * n
    return sum

l = [1, 2, 3, 4, 5, 6, 7]
print(calc(l)) # 140
# 其实这种方法也挺方便, 但是使用可变参数会更简洁~
# 可变参数的定义方法, 就是在参数前面加一颗星星 *
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum += n * n
    return sum
# 这样, 我在调用 calc 函数的时候就可以传入任意数量的参数了!
print(calc()) # 0
print(calc(1)) # 1
print(calc(1, 2, 3)) # 14
print(calc(1, 2, 3, 4, 5, 6, 7)) # 140
# 因为函数定义时使用了可变参数, 所以上述7个参数传入实质上还是把7个参数存放在一个元组中传入的.
# 可以理解为: 可变参数先对你传入的参数用元组封装一下, 然后往函数中直接传入一个元组.

# 如果已经有了一个 list 或 tuple, 要调用可变参数, 应该怎么用呢?
nums = [1, 2, 3]
# 当然可以这样传入: calc(nums[0], nums[1], nums[2]), 但这样太繁琐了!
# Python 支持你在 list 或 tuple 前加一个 * 号, 即可将其中的元素变成可变参数传入了! ⭐️
print(calc(*nums)) # 14

# 练习: 编写一个函数, 可以对任意个数字进行求和.
def get_sum(*nums):
    sum = 0
    for n in nums:
        sum += n
    return sum

print(get_sum(1, 2, 3, 4, 5)) # 15
t = (1, 2, 3, 4, 5)
print(get_sum(*t)) # 15

# 装包与拆包
# 可变参数的本质
# a, b, c = 1, 2, 3, 4, 5 # 这里会报错
a, *b, c = 1, 2, 3, 4, 5
print(a) # 1
print(b) # [2, 3, 4] 这个过程就是装包
print(c) # 5

a, b, c = (1, 2, 3) # 这个过程是拆包
print(a, b, c) # 1 2 3 

# a, b, c = (1, 2, 3, 4, 5) # 报错
a, *b, c = (1, 2, 3, 4, 5)
print(a, b, c) # 1 [2, 3, 4] 5

'''
拆包和装包:
    函数装包:
        定义的时候 def method(*args) ---> 此时会出现装包
    list/tuple/set 拆包:
        调用的时候 method(*list) method(*tuple) method(*set) ---> 此时会出现拆包
'''


print('*2.4-' * 20)
# 2.4 关键字参数
# 可变参数允许你往函数中传入0个或任意个参数, 这些可变参数在函数调用时会自动组装成一个 tuple.
# 而关键字参数允许你传入0个或任意个含参数名的参数, 这些关键字参数会自动组装成一个 dict.
'''
可以这么理解:
- 可变参数是位置参数的升级(不限制数量).
- 关键字参数是默认参数的升级(不限制数量).
'''
# 举例说明: 打印用户注册信息
def person(name, age, **kw):
    print('姓名:', name, '年龄:', age, '其他信息:', kw)
# 在 person 函数中, 只有姓名和年龄是必要信息, 其他都是可选的.
# 我们可以在调用时只传入必要信息.
person('胡楠', 31) # 姓名: 胡楠 年龄: 31 其他信息: {}
# 这有什么用处呢?
'''
关键字参数的用处: 它可以扩展函数的功能. 比如在编写注册功能时, 除了姓名和年龄之外, 用户想要传入其他信息,
函数也可以接收! 关键字参数就可以实现此功能.
'''
person('胡楠', 31, city='淮南', gender='M', job='工程师')
# 姓名: 胡楠 年龄: 31 其他信息: {'city': '淮南', 'gender': 'M', 'job': '工程师'}
# 可以看出, 我传入的 key-value 对被函数中的 kw 以字典的格式接收了.

# 就像给定 list 或 tuple, 传入可变参数一样.
# 如果给定一个 dict, 传入关键字参数该怎么传?
extra = {'city': 'Beijing', 'job': 'Engineer'}
person('张三', 41, **extra)
# 它等价于:
# person('张三', 41, city=extra['city'], job=extra['job'])

'''
记住:
- 可变参数 *numbers 传参之后, 函数体中的 numbers 是一个元组.
- 关键字参数 **kw 传参之后, 函数体中的 kw 是一个字典!
    - 这些名称不重要, 可以自定义.
'''

def show_book(**kw):
    print(kw)
    for k, v in kw.items():
        print(k, v)

d = {'name': '胡楠', 'gender': '男', 'age': 31}
show_book(**d)


print('*2.5-' * 20)
# 2.5 既用 *args, 又用 **kw
def show_book(*args, **kw): # 一个代表元组, 一个代表字典.
    print(args) # ()
    print(kw) # {}

show_book('测试', '道德经', book='三国演义', author='罗贯中')
# ('测试', '道德经')
# {'book': '三国演义', 'author': '罗贯中'}
# 可以看出, 不带关键字的参数全都给 args 了, 带关键字的参数全都给 kw 了.
'''
注: 可变参数要放在关键字参数的前面! 顺序不可颠倒.
'''


print('*3-' * 20)
# 3. 函数的返回值
# 参数是从外面往函数内部传值, 返回值是从函数内部往外送值.
# 练习: 从列表中找出最大值和最小值, 并返回.
def get_max_min(numbers):
    return max(numbers), min(numbers)

l = [1, 2, 3, 7, 8, 9]
print(get_max_min(l)) # (9, 1) 


# 4. 全局变量和局部变量
'''
    - 声明在函数外边的变量, 是全局变量.
    - 声明在函数内部的变量, 是局部变量.
    - 可以在函数内部使用全局变量, 但不可修改(因为没有权限, 修改会报错).
        - 全局变量如果是可变对象, 则可以在函数内部修改; 如果是不可变对象, 则不能.
        - 如果想在函数内部修改不可变的全局变量, 可以加 global 关键字
    - 在函数内部定义与全局变量同名的局部变量, 则函数内部使用的均为局部变量, 与全局变量无关.
    - 查看当前所有全局变量, 用 globals().
'''
a = 100 # 全局变量

def test1():
    a = 0 # 局部变量(这里不是将全局变量改为0, 而是重新定义了一个局部变量 a, 将其赋值为0)
    print('a =', a)

def test2():
    print('a =', a) # 这里在使用全局变量.

test1() # a = 0
test2() # a = 100
'''
为什么都是打印 a, 结果却不一样?
因为在 Python 中, 对变量的的检索是使用就近原则的, 先看函数内部有没有此变量, 如果没有, 再往外部找.
对于 test1 中的打印操作, a 会先往上找到 a=0, 所以打印出的结果是0.
对于 test2 中的打印操作, test2 内部没有定义 a, 所以会向外部找(但不会往其他函数中找), 找到了 a=100.
'''
def test3(): 
    global a # 在这里声明一下全局变量.
    # 在这里想改变全局变量a的值, 但直接这样写会报错, 因为你可以看一下全局变量, 但没有改的权限. 所以, 需要加上上一行.
    a -= 10 # 这里对全局变量进行修改.
    print('a =', a) # a = 90, 对全局变量修改成功

test3()
test2() # 再次调用 test2, 发现 a 也变成90了.

print(globals())


# 5. 可变对象与不可变对象
# 上面已经介绍了全局变量和局部变量, 已经知晓了在函数内部想要修改全局变量需要在 global 关键字.
# 但为何修改全局的列表不用加 global?
l = []
def append_l():
    l.append('1')

def print_l():
    print(l)

append_l()
print_l() # ['1']
append_l()
print_l() # ['1', '1']
# 为了解答这个问题, 我们需要引入"可变对象"和"不可变对象"!

'''
只有不可变类型才需要加 global, 
可变的类型不需要添加 global.
'''
# 5.1 不可变类型: 当改变变量的值时, 其地址也会发生变化.
# 常用的不可变类型: 整型, 字符串, float, bool, tuple
a = 100
print('int:', id(a))
a = 90
print('int:',id(a))
# 可以看出, 地址是不一样的. 这里并不是直接将100改成了90, 而是先在内存里存了一个整型数字100, 用 a 指向改数字;
# 将 a 修改成90时, 实际过程是这样的: 再生成了一个整型数字90, 将 a 的指针重新指向90.
# 所以, int 是不可变对象.
c = 100
print('int:',id(c)) # 这里的地址和第一个 a 是一样的.

t1 = (1, 2, 3)
print('tuple:', id(t1))
t1 = (1, 2, 3, 4)
print('tuple:', id(t1))
t2 = (1, 2, 3)
print('tuple:', id(t2)) # 可以看出, 这里 t2 的地址和第一个 t1 也是一样的.
'''
原因: 所有不可变对象都会产生类似于常量池一样的东西.
'''
# 5.2 可变类型: 当改变变量的值时, 其地址不会发生变化.
# 常见可变类型: list, dict, set, 所有具备往里面添加元素的方法的类型, 都是可变类型.


# 6. 函数的注释: VS Code 需要安装一个 autoDocstring 扩展, 然后在函数体内输入三个双引号即可.
def login(username, password):
    """此函数用于验证用户是否登录成功.

    Args:
        username (string): 传入用户名
        password (string): 传入密码

    Returns:
        bool: 登录成功返回 True, 否则返回 False
    """
    if username == 'admin' and password == '1234':
        print('登录成功')
        return True
    else:
        print('用户名或密码错误')
        return False

login('admin', '1234') # 这样在调用函数时, 鼠标放在上面能看到函数相关信息.